We present \emph{abstract refinement types} which enable 
quantification over the refinements of data- and 
function-types. Our key insight is that we 
can avail of quantification while preserving SMT-based 
decidability, simply by encoding refinement parameters
as \emph{uninterpreted} propositions within the ground 
refinement logic.
%
We illustrate how this simple mechanism yields a variety 
of sophisticated and automatic means for reasoning about 
programs, including:
\emph{parametric} refinements for reasoning with type classes,
\emph{index-dependent} refinements for reasoning about key-value maps,
\emph{recursive} refinements for reasoning about data structures, and
\emph{inductive} refinements for reasoning about higher-order traversal routines.
%
We have implemented our approach in \toolname, a refinement
type checker for Haskell, and present experiments using
\toolname to verify correctness invariants of various programs.
%including some \textsc{GHC} libraries.
